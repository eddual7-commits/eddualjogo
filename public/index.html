<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üßü Zombie Survival - Terraria Style</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
        }
        
        /* ==================== MENU ==================== */
        #menu {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #1a0a2e 0%, #0d0d0d 50%, #1a0505 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .menu-hidden { display: none !important; }
        
        #menu h1 {
            font-size: 4em;
            color: #00ff44;
            text-shadow: 0 0 20px #00ff4488, 0 0 40px #00ff4444, 0 4px 0 #005500;
            margin-bottom: 10px;
            letter-spacing: 3px;
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        #menu h2 {
            font-size: 1.5em;
            color: #ff4444;
            text-shadow: 0 0 10px #ff000088;
            margin-bottom: 40px;
            font-style: italic;
        }
        
        .menu-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 30px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 40px rgba(0, 255, 68, 0.2), inset 0 0 50px rgba(0, 0, 0, 0.5);
        }
        
        .menu-section {
            margin-bottom: 25px;
        }
        
        .menu-section label {
            display: block;
            color: #aaa;
            margin-bottom: 8px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .menu-section input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            color: #fff;
            font-size: 1.1em;
            outline: none;
            transition: all 0.3s;
        }
        
        .menu-section input[type="text"]:focus {
            border-color: #00ff44;
            box-shadow: 0 0 15px rgba(0, 255, 68, 0.3);
        }
        
        .color-picker {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .color-option {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.2s;
            position: relative;
        }
        
        .color-option:hover {
            transform: scale(1.15);
        }
        
        .color-option.selected {
            border-color: #fff;
            box-shadow: 0 0 15px currentColor;
        }
        
        .btn {
            width: 100%;
            padding: 15px 30px;
            font-size: 1.2em;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        
        .btn-primary {
            background: linear-gradient(180deg, #00ff44 0%, #00aa22 100%);
            color: #000;
            box-shadow: 0 5px 20px rgba(0, 255, 68, 0.4);
        }
        
        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 255, 68, 0.6);
        }
        
        .btn-secondary {
            background: linear-gradient(180deg, #444 0%, #222 100%);
            color: #fff;
        }
        
        .btn-secondary:hover {
            background: linear-gradient(180deg, #555 0%, #333 100%);
        }
        
        /* Server List */
        .server-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .server-item {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .server-item:hover {
            background: #252525;
            border-color: #00ff44;
        }
        
        .server-item.selected {
            border-color: #00ff44;
            box-shadow: 0 0 10px rgba(0, 255, 68, 0.3);
        }
        
        .server-info h3 {
            color: #fff;
            margin-bottom: 4px;
        }
        
        .server-info span {
            color: #888;
            font-size: 0.85em;
        }
        
        .server-players {
            color: #00ff44;
            font-weight: bold;
        }
        
        /* ==================== LOADING ==================== */
        #loading {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #0a0a0a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
        
        .loading-hidden { display: none !important; }
        
        .loading-bar-container {
            width: 300px;
            height: 20px;
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 20px;
        }
        
        .loading-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #00ff44, #00aa22);
            transition: width 0.3s;
        }
        
        .loading-text {
            color: #888;
            margin-top: 15px;
        }
        
        /* ==================== GAME CANVAS ==================== */
        #gameContainer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* ==================== HUD ==================== */
        #hud {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 100;
        }
        
        #hud > * {
            pointer-events: auto;
        }
        
        /* Top Bar */
        .top-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            align-items: center;
        }
        
        .stat-bar {
            width: 200px;
            height: 24px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }
        
        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .health-bar .stat-bar-fill {
            background: linear-gradient(180deg, #ff4444 0%, #aa0000 100%);
        }
        
        .xp-bar {
            width: 150px;
            height: 18px;
        }
        
        .xp-bar .stat-bar-fill {
            background: linear-gradient(180deg, #44ff44 0%, #00aa00 100%);
        }
        
        .stat-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }
        
        /* Wave Info */
        .wave-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #333;
        }
        
        .wave-number {
            color: #ff4444;
            font-size: 1.5em;
            font-weight: bold;
        }
        
        .wave-timer {
            color: #aaa;
            font-size: 0.9em;
        }
        
        /* Day/Night Indicator */
        .time-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 10px;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .time-icon {
            font-size: 1.5em;
        }
        
        /* Hotbar */
        .hotbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 10px;
            border: 2px solid #333;
        }
        
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background: rgba(50, 50, 50, 0.8);
            border: 2px solid #444;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .hotbar-slot.selected {
            border-color: #00ff44;
            box-shadow: 0 0 15px rgba(0, 255, 68, 0.5), inset 0 0 10px rgba(0, 255, 68, 0.2);
            transform: translateY(-3px);
        }
        
        .hotbar-slot:hover {
            border-color: #666;
        }
        
        .hotbar-slot .item-icon {
            font-size: 24px;
        }
        
        .hotbar-slot .item-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 11px;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
            font-weight: bold;
        }
        
        .hotbar-slot .slot-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #666;
        }
        
        /* Minimap */
        .minimap {
            position: absolute;
            bottom: 80px;
            right: 10px;
            width: 150px;
            height: 100px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .minimap canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Chat */
        .chat-container {
            position: absolute;
            bottom: 80px;
            left: 10px;
            width: 300px;
        }
        
        .chat-messages {
            height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px 10px 0 0;
            padding: 10px;
        }
        
        .chat-message {
            margin-bottom: 5px;
            font-size: 13px;
            word-wrap: break-word;
        }
        
        .chat-message .name {
            font-weight: bold;
        }
        
        .chat-message .text {
            color: #ddd;
        }
        
        .chat-input-container {
            display: flex;
        }
        
        .chat-input {
            flex: 1;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: none;
            border-radius: 0 0 0 10px;
            color: #fff;
            outline: none;
        }
        
        .chat-send {
            padding: 10px 15px;
            background: #00ff44;
            color: #000;
            border: none;
            border-radius: 0 0 10px 0;
            cursor: pointer;
            font-weight: bold;
        }
        
        /* Mobile Controls */
        .mobile-controls {
            display: none;
        }
        
        @media (max-width: 768px), (pointer: coarse) {
            .mobile-controls {
                display: block;
            }
            
            .chat-container {
                width: 200px;
                opacity: 0.7;
            }
            
            .minimap {
                width: 100px;
                height: 70px;
            }
        }
        
        .joystick-container {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        
        .joystick-left {
            bottom: 20px;
            left: 20px;
        }
        
        .joystick-right {
            bottom: 20px;
            right: 20px;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .mobile-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #fff;
        }
        
        .jump-btn {
            bottom: 150px;
            left: 140px;
        }
        
        .attack-btn {
            bottom: 150px;
            right: 140px;
        }
        
        /* Damage Numbers */
        .damage-number {
            position: absolute;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 2px 2px 2px #000;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 200;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.5); }
        }
        
        /* Notifications */
        .notification {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.2em;
            z-index: 300;
            animation: notifyIn 0.3s ease-out;
        }
        
        @keyframes notifyIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .notification.wave {
            border: 2px solid #ff4444;
            color: #ff4444;
        }
        
        .notification.boss {
            border: 2px solid #ff00ff;
            color: #ff00ff;
            font-size: 1.5em;
        }
        
        .notification.level {
            border: 2px solid #44ff44;
            color: #44ff44;
        }
    </style>
</head>
<body>
    <!-- MENU -->
    <div id="menu">
        <h1>üßü ZOMBIE SURVIVAL</h1>
        <h2>‚õèÔ∏è Terraria Style Edition</h2>
        
        <div class="menu-container">
            <div class="menu-section">
                <label>üë§ Seu Nome</label>
                <input type="text" id="playerName" placeholder="Digite seu nome..." maxlength="20" value="">
            </div>
            
            <div class="menu-section">
                <label>üé® Cor do Personagem</label>
                <div class="color-picker" id="colorPicker">
                    <div class="color-option selected" style="background: #00ff44" data-color="#00ff44"></div>
                    <div class="color-option" style="background: #ff4444" data-color="#ff4444"></div>
                    <div class="color-option" style="background: #4444ff" data-color="#4444ff"></div>
                    <div class="color-option" style="background: #ffff44" data-color="#ffff44"></div>
                    <div class="color-option" style="background: #ff44ff" data-color="#ff44ff"></div>
                    <div class="color-option" style="background: #44ffff" data-color="#44ffff"></div>
                    <div class="color-option" style="background: #ff8800" data-color="#ff8800"></div>
                    <div class="color-option" style="background: #ffffff" data-color="#ffffff"></div>
                </div>
            </div>
            
            <div class="menu-section">
                <label>üåê Servidores Dispon√≠veis</label>
                <div class="server-list" id="serverList">
                    <div class="server-item selected" data-server="main">
                        <div class="server-info">
                            <h3>Servidor Principal</h3>
                            <span>Wave 1 ‚Ä¢ Ping: --ms</span>
                        </div>
                        <div class="server-players">0/10</div>
                    </div>
                </div>
                <button class="btn btn-secondary" id="refreshServers">üîÑ Atualizar Lista</button>
            </div>
            
            <button class="btn btn-primary" id="playBtn">‚öîÔ∏è JOGAR</button>
        </div>
    </div>
    
    <!-- LOADING -->
    <div id="loading" class="loading-hidden">
        <h1 style="color: #00ff44; margin-bottom: 20px;">üßü ZOMBIE SURVIVAL</h1>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Gerando mundo...</div>
    </div>
    
    <!-- GAME -->
    <div id="gameContainer" style="display: none;">
        <canvas id="gameCanvas"></canvas>
        
        <!-- HUD -->
        <div id="hud">
            <!-- Top Bar -->
            <div class="top-bar">
                <div class="stat-bar health-bar">
                    <div class="stat-bar-fill" id="healthFill" style="width: 100%"></div>
                    <div class="stat-bar-text" id="healthText">100/100</div>
                </div>
                <div class="stat-bar xp-bar">
                    <div class="stat-bar-fill" id="xpFill" style="width: 0%"></div>
                    <div class="stat-bar-text" id="levelText">Lv.1</div>
                </div>
            </div>
            
            <!-- Time Indicator -->
            <div class="time-indicator">
                <span class="time-icon" id="timeIcon">‚òÄÔ∏è</span>
                <span id="timeText">Dia</span>
            </div>
            
            <!-- Wave Info -->
            <div class="wave-info">
                <div class="wave-number">Wave <span id="waveNumber">1</span></div>
                <div class="wave-timer">Pr√≥xima: <span id="waveTimer">90</span>s</div>
            </div>
            
            <!-- Hotbar -->
            <div class="hotbar" id="hotbar"></div>
            
            <!-- Minimap -->
            <div class="minimap">
                <canvas id="minimapCanvas"></canvas>
            </div>
            
            <!-- Chat -->
            <div class="chat-container">
                <div class="chat-messages" id="chatMessages"></div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="Pressione Enter para chat..." maxlength="200">
                    <button class="chat-send" id="chatSend">‚û§</button>
                </div>
            </div>
            
            <!-- Mobile Controls -->
            <div class="mobile-controls">
                <div class="joystick-container joystick-left" id="joystickLeft">
                    <div class="joystick-knob" id="knobLeft"></div>
                </div>
                <div class="joystick-container joystick-right" id="joystickRight">
                    <div class="joystick-knob" id="knobRight"></div>
                </div>
                <div class="mobile-btn jump-btn" id="jumpBtn">‚¨ÜÔ∏è</div>
                <div class="mobile-btn attack-btn" id="attackBtn">‚öîÔ∏è</div>
            </div>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
// ==================== CONTINUA√á√ÉO NO PR√ìXIMO BLOCO ====================
    </script>
</body>
</html>
<script>
// ==================== CONFIGURA√á√ïES ====================
const CONFIG = {
    TILE_SIZE: 16,
    RENDER_DISTANCE: 50,
    LIGHT_QUALITY: 1, // 1 = full, 2 = half, 4 = quarter
    SHOW_FPS: true,
    PARALLAX_LAYERS: 4,
    PARTICLE_LIMIT: 200
};

// ==================== ESTADO DO JOGO ====================
const Game = {
    socket: null,
    canvas: null,
    ctx: null,
    minimapCanvas: null,
    minimapCtx: null,
    
    // Estado
    connected: false,
    playing: false,
    playerId: null,
    
    // Mundo
    world: null,
    lightMap: null,
    
    // Entidades
    players: new Map(),
    zombies: new Map(),
    projectiles: new Map(),
    items: new Map(),
    particles: [],
    damageNumbers: [],
    
    // Jogador local
    player: null,
    camera: { x: 0, y: 0 },
    
    // Input
    keys: {},
    mouse: { x: 0, y: 0, down: false, button: 0 },
    joystick: { left: { x: 0, y: 0, active: false }, right: { x: 0, y: 0, active: false } },
    
    // Tempo
    dayTime: 0.25,
    wave: 1,
    waveTimer: 90,
    
    // Performance
    fps: 0,
    frameCount: 0,
    lastFpsUpdate: 0,
    lastUpdate: 0,
    
    // UI
    selectedSlot: 0,
    chatOpen: false,
    
    // Assets
    sprites: {},
    colors: {}
};

// ==================== CORES DOS TILES ====================
const TILE_COLORS = {
    0: null, // AIR
    1: ['#8B5A2B', '#7A4F26', '#6B4423'], // DIRT
    2: ['#4CAF50', '#45A049', '#3D8B40'], // GRASS
    3: ['#808080', '#707070', '#606060'], // STONE
    4: ['#8B4513', '#7A3C10', '#6B330D'], // WOOD
    5: ['#228B22', '#1E7B1E', '#1A6B1A'], // LEAVES
    6: ['#2F2F2F', '#252525', '#1F1F1F'], // COAL
    7: ['#C19A6B', '#B08A5B', '#A07A4B'], // IRON
    8: ['#FFD700', '#E6C200', '#CCB000'], // GOLD
    9: ['#00FFFF', '#00E5E5', '#00CCCC'], // DIAMOND
    10: ['#F4D03F', '#E5C135', '#D6B22B'], // SAND
    11: ['#4169E1', '#3A5FCC', '#3355B7'], // WATER
    12: ['#FF4500', '#E63E00', '#CC3700'], // LAVA
    13: ['#696969', '#5F5F5F', '#555555'], // COBBLESTONE
    14: ['#DEB887', '#CFA877', '#C09867'], // PLANKS
    15: ['#FFA500', '#FF8C00', '#FF7400'], // TORCH
    16: ['#8B4513', '#7A3C10', '#6B330D'], // CHEST
    17: ['#A0522D', '#8B4726', '#763C1F'], // WORKBENCH
    18: ['#464646', '#3C3C3C', '#323232'], // FURNACE
    19: ['#1A1A1A', '#0F0F0F', '#050505'], // BEDROCK
    20: ['#B87333', '#A66329', '#94531F'], // COPPER
    21: ['#C0C0C0', '#B0B0B0', '#A0A0A0'], // SILVER
    22: ['#1A0033', '#0F001A', '#050008'], // OBSIDIAN
    23: ['#ADD8E6', '#9DC8D6', '#8DB8C6'], // GLASS
    24: ['#8B0000', '#7A0000', '#6B0000'], // BRICK
    25: ['#8B4513', '#7A3C10', '#6B330D'], // PLATFORM
    26: ['#654321', '#5A3B1D', '#4F3319'], // DOOR_BOTTOM
    27: ['#654321', '#5A3B1D', '#4F3319'], // DOOR_TOP
    28: ['#FFFAFA', '#F0EAEA', '#E0DADA'], // SNOW
    29: ['#E0FFFF', '#D0EFEF', '#C0DFDF'], // ICE
    30: ['#2E8B57', '#268B4D', '#1E7B43']  // CACTUS
};

// ==================== INICIALIZA√á√ÉO ====================
function init() {
    // Canvas principal
    Game.canvas = document.getElementById('gameCanvas');
    Game.ctx = Game.canvas.getContext('2d');
    
    // Canvas do minimap
    Game.minimapCanvas = document.getElementById('minimapCanvas');
    Game.minimapCtx = Game.minimapCanvas.getContext('2d');
    
    // Resize
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Socket.io
    Game.socket = io();
    setupSocketEvents();
    
    // Eventos de input
    setupInputEvents();
    
    // Eventos do menu
    setupMenuEvents();
    
    // Hotbar
    createHotbar();
    
    // Solicita lista de servidores
    Game.socket.emit('getServers');
    
    // Inicia loop de renderiza√ß√£o
    requestAnimationFrame(gameLoop);
    
    console.log('üßü Zombie Survival Terraria initialized!');
}

function resizeCanvas() {
    Game.canvas.width = window.innerWidth;
    Game.canvas.height = window.innerHeight;
    Game.minimapCanvas.width = 150;
    Game.minimapCanvas.height = 100;
}

// ==================== EVENTOS DO SOCKET ====================
function setupSocketEvents() {
    const socket = Game.socket;
    
    socket.on('connect', () => {
        console.log('Connected to server');
        Game.connected = true;
    });
    
    socket.on('disconnect', () => {
        console.log('Disconnected from server');
        Game.connected = false;
        Game.playing = false;
    });
    
    socket.on('serverList', (servers) => {
        updateServerList(servers);
    });
    
    socket.on('serverCreated', (data) => {
        console.log('Server created:', data.serverId);
    });
    
    socket.on('joinSuccess', (data) => {
        console.log('Joined game!', data);
        
        Game.playerId = data.playerId;
        Game.player = data.player;
        Game.world = data.world;
        Game.dayTime = data.time;
        Game.wave = data.wave;
        Game.waveTimer = data.waveTimer;
        
        // Cria lightmap
        createLightMap();
        
        // Esconde menu, mostra jogo
        document.getElementById('loading').classList.add('loading-hidden');
        document.getElementById('menu').classList.add('menu-hidden');
        document.getElementById('gameContainer').style.display = 'block';
        
        Game.playing = true;
        
        // Centra c√¢mera no jogador
        Game.camera.x = Game.player.x - Game.canvas.width / 2;
        Game.camera.y = Game.player.y - Game.canvas.height / 2;
        
        updateHotbar();
    });
    
    socket.on('joinError', (data) => {
        alert(data.message);
        document.getElementById('loading').classList.add('loading-hidden');
        document.getElementById('menu').classList.remove('menu-hidden');
    });
    
    socket.on('gameState', (state) => {
        Game.dayTime = state.time;
        Game.wave = state.wave;
        Game.waveTimer = state.waveTimer;
        
        // Atualiza jogadores
        Game.players.clear();
        state.players.forEach(p => {
            Game.players.set(p.id, p);
            if (p.id === Game.playerId) {
                // Atualiza jogador local com dados do servidor
                Object.assign(Game.player, p);
            }
        });
        
        // Atualiza zumbis
        Game.zombies.clear();
        state.zombies.forEach(z => Game.zombies.set(z.id, z));
        
        // Atualiza proj√©teis
        Game.projectiles.clear();
        state.projectiles.forEach(p => Game.projectiles.set(p.id, p));
        
        // Atualiza itens
        Game.items.clear();
        state.items.forEach(i => Game.items.set(i.id, i));
        
        // Atualiza UI
        updateUI();
    });
    
    socket.on('playerJoined', (data) => {
        console.log('Player joined:', data.player.name);
        addChatMessage('Sistema', `${data.player.name} entrou no jogo`, '#44ff44');
    });
    
    socket.on('playerLeft', (data) => {
        const player = Game.players.get(data.playerId);
        if (player) {
            addChatMessage('Sistema', `${player.name} saiu do jogo`, '#ff4444');
        }
        Game.players.delete(data.playerId);
    });
    
    socket.on('blockBroken', (data) => {
        if (Game.world) {
            Game.world.tiles[data.x][data.y] = 0;
            updateLocalLight(data.x, data.y);
        }
        // Part√≠culas
        createBlockParticles(data.x * CONFIG.TILE_SIZE, data.y * CONFIG.TILE_SIZE);
    });
    
    socket.on('blockPlaced', (data) => {
        if (Game.world) {
            Game.world.tiles[data.x][data.y] = data.tile;
            updateLocalLight(data.x, data.y);
        }
    });
    
    socket.on('playerDamaged', (data) => {
        if (data.playerId === Game.playerId) {
            // Screen shake
            Game.camera.shakeX = (Math.random() - 0.5) * 10;
            Game.camera.shakeY = (Math.random() - 0.5) * 10;
            
            // Efeito vermelho
            Game.damageFlash = 1;
        }
        
        // N√∫mero de dano
        const player = Game.players.get(data.playerId);
        if (player) {
            addDamageNumber(player.x, player.y - 30, data.damage, '#ff4444');
        }
    });
    
    socket.on('zombieDeath', (data) => {
        // Part√≠culas de morte
        for (let i = 0; i < 10; i++) {
            Game.particles.push({
                x: data.x,
                y: data.y,
                vx: (Math.random() - 0.5) * 5,
                vy: -Math.random() * 5,
                size: 3 + Math.random() * 3,
                color: '#8B0000',
                life: 1,
                gravity: 0.2
            });
        }
    });
    
    socket.on('playerAttack', (data) => {
        const player = Game.players.get(data.playerId);
        if (player) {
            player.attacking = true;
            player.attackAnim = 0;
        }
    });
    
    socket.on('newWave', (data) => {
        showNotification(`‚öîÔ∏è WAVE ${data.wave}`, 'wave');
        addChatMessage('Sistema', `Wave ${data.wave} come√ßou!`, '#ff4444');
    });
    
    socket.on('bossSpawn', (data) => {
        showNotification('üíÄ BOSS APARECEU!', 'boss');
        addChatMessage('Sistema', 'Um BOSS apareceu!', '#ff00ff');
    });
    
    socket.on('levelUp', (data) => {
        if (data.playerId === Game.playerId) {
            showNotification(`üéâ LEVEL ${data.level}!`, 'level');
        }
    });
    
    socket.on('itemCollected', (data) => {
        if (data.playerId === Game.playerId) {
            updateHotbar();
        }
    });
    
    socket.on('chatMessage', (data) => {
        addChatMessage(data.playerName, data.message, Game.players.get(data.playerId)?.color || '#ffffff');
    });
}

// ==================== EVENTOS DE INPUT ====================
function setupInputEvents() {
    // Teclado
    window.addEventListener('keydown', (e) => {
        if (Game.chatOpen && e.key !== 'Escape' && e.key !== 'Enter') return;
        
        Game.keys[e.code] = true;
        
        // N√∫meros para hotbar
        if (e.key >= '1' && e.key <= '9') {
            Game.selectedSlot = parseInt(e.key) - 1;
            Game.socket.emit('selectSlot', Game.selectedSlot);
            updateHotbar();
        }
        
        // Chat
        if (e.key === 'Enter') {
            toggleChat();
        }
        
        if (e.key === 'Escape') {
            if (Game.chatOpen) {
                toggleChat();
            }
        }
    });
    
    window.addEventListener('keyup', (e) => {
        Game.keys[e.code] = false;
    });
    
    // Mouse
    Game.canvas.addEventListener('mousemove', (e) => {
        Game.mouse.x = e.clientX;
        Game.mouse.y = e.clientY;
    });
    
    Game.canvas.addEventListener('mousedown', (e) => {
        Game.mouse.down = true;
        Game.mouse.button = e.button;
        handleClick(e);
    });
    
    Game.canvas.addEventListener('mouseup', (e) => {
        Game.mouse.down = false;
    });
    
    Game.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
    
    // Scroll para zoom (opcional)
    Game.canvas.addEventListener('wheel', (e) => {
        // Pode implementar zoom aqui
    });
    
    // Touch/Mobile
    setupMobileControls();
}

function setupMobileControls() {
    const joystickLeft = document.getElementById('joystickLeft');
    const knobLeft = document.getElementById('knobLeft');
    const joystickRight = document.getElementById('joystickRight');
    const knobRight = document.getElementById('knobRight');
    const jumpBtn = document.getElementById('jumpBtn');
    const attackBtn = document.getElementById('attackBtn');
    
    let leftTouch = null;
    let rightTouch = null;
    
    // Joystick esquerdo (movimento)
    joystickLeft.addEventListener('touchstart', (e) => {
        e.preventDefault();
        leftTouch = e.touches[0].identifier;
        Game.joystick.left.active = true;
    });
    
    // Joystick direito (mira)
    joystickRight.addEventListener('touchstart', (e) => {
        e.preventDefault();
        rightTouch = e.touches[0].identifier;
        Game.joystick.right.active = true;
    });
    
    window.addEventListener('touchmove', (e) => {
        for (let touch of e.touches) {
            if (touch.identifier === leftTouch) {
                const rect = joystickLeft.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.hypot(dx, dy);
                const maxDist = rect.width / 2 - 25;
                
                if (dist > maxDist) {
                    dx = dx / dist * maxDist;
                    dy = dy / dist * maxDist;
                }
                
                knobLeft.style.left = `calc(50% + ${dx}px)`;
                knobLeft.style.top = `calc(50% + ${dy}px)`;
                
                Game.joystick.left.x = dx / maxDist;
                Game.joystick.left.y = dy / maxDist;
            }
            
            if (touch.identifier === rightTouch) {
                const rect = joystickRight.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const dist = Math.hypot(dx, dy);
                const maxDist = rect.width / 2 - 25;
                
                if (dist > maxDist) {
                    dx = dx / dist * maxDist;
                    dy = dy / dist * maxDist;
                }
                
                knobRight.style.left = `calc(50% + ${dx}px)`;
                knobRight.style.top = `calc(50% + ${dy}px)`;
                
                Game.joystick.right.x = dx / maxDist;
                Game.joystick.right.y = dy / maxDist;
            }
        }
    });
    
    window.addEventListener('touchend', (e) => {
        for (let touch of e.changedTouches) {
            if (touch.identifier === leftTouch) {
                leftTouch = null;
                Game.joystick.left = { x: 0, y: 0, active: false };
                knobLeft.style.left = '50%';
                knobLeft.style.top = '50%';
            }
            if (touch.identifier === rightTouch) {
                rightTouch = null;
                Game.joystick.right = { x: 0, y: 0, active: false };
                knobRight.style.left = '50%';
                knobRight.style.top = '50%';
            }
        }
    });
    
    // Bot√£o de pulo
    jumpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        Game.keys['Space'] = true;
    });
    jumpBtn.addEventListener('touchend', (e) => {
        Game.keys['Space'] = false;
    });
    
    // Bot√£o de ataque
    attackBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (Game.playing && Game.player) {
            const worldX = Game.player.x + (Game.player.facingRight ? 40 : -40);
            const worldY = Game.player.y;
            Game.socket.emit('playerAction', { type: 'attack', x: worldX, y: worldY });
        }
    });
}

function handleClick(e) {
    if (!Game.playing || !Game.player) return;
    
    const worldX = Game.mouse.x + Game.camera.x;
    const worldY = Game.mouse.y + Game.camera.y;
    
    if (e.button === 0) {
        // Clique esquerdo - Ataque/Minera√ß√£o
        const item = Game.player.hotbar?.[Game.selectedSlot];
        
        if (item?.type === 'pickaxe') {
            // Minerar bloco
            Game.socket.emit('playerAction', { type: 'break', x: worldX, y: worldY });
        } else {
            // Atacar
            Game.socket.emit('playerAction', { type: 'attack', x: worldX, y: worldY });
        }
    } else if (e.button === 2) {
        // Clique direito - Colocar bloco
        Game.socket.emit('playerAction', { type: 'place', x: worldX, y: worldY });
    }
}

// ==================== MENU ====================
function setupMenuEvents() {
    // Cores
    document.querySelectorAll('.color-option').forEach(el => {
        el.addEventListener('click', () => {
            document.querySelectorAll('.color-option').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
        });
    });
    
    // Bot√£o jogar
    document.getElementById('playBtn').addEventListener('click', () => {
        const name = document.getElementById('playerName').value.trim() || 'Jogador';
        const color = document.querySelector('.color-option.selected').dataset.color;
        const serverItem = document.querySelector('.server-item.selected');
        const serverId = serverItem?.dataset.server || 'main';
        
        // Mostra loading
        document.getElementById('menu').classList.add('menu-hidden');
        document.getElementById('loading').classList.remove('loading-hidden');
        
        // Simula carregamento
        let progress = 0;
        const loadingBar = document.getElementById('loadingBar');
        const loadingText = document.getElementById('loadingText');
        
        const loadingSteps = [
            'Conectando ao servidor...',
            'Gerando mundo...',
            'Carregando texturas...',
            'Preparando zumbis...',
            'Iniciando jogo...'
        ];
        
        const loadInterval = setInterval(() => {
            progress += 5;
            loadingBar.style.width = progress + '%';
            loadingText.textContent = loadingSteps[Math.floor(progress / 25)] || loadingSteps[loadingSteps.length - 1];
            
            if (progress >= 100) {
                clearInterval(loadInterval);
                Game.socket.emit('joinGame', {
                    serverId: serverId === 'main' ? null : serverId,
                    playerName: name,
                    playerColor: color
                });
            }
        }, 50);
    });
    
    // Refresh servidores
    document.getElementById('refreshServers').addEventListener('click', () => {
        Game.socket.emit('getServers');
    });
    
    // Chat
    document.getElementById('chatSend').addEventListener('click', sendChatMessage);
    document.getElementById('chatInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            sendChatMessage();
        }
    });
}

function updateServerList(servers) {
    const list = document.getElementById('serverList');
    list.innerHTML = '';
    
    // Adiciona servidor padr√£o se n√£o houver nenhum
    if (servers.length === 0) {
        servers = [{ id: 'main', name: 'Servidor Principal', players: 0, maxPlayers: 10, wave: 1 }];
    }
    
    servers.forEach((server, index) => {
        const div = document.createElement('div');
        div.className = 'server-item' + (index === 0 ? ' selected' : '');
        div.dataset.server = server.id;
        div.innerHTML = `
            <div class="server-info">
                <h3>${server.name}</h3>
                <span>Wave ${server.wave}</span>
            </div>
            <div class="server-players">${server.players}/${server.maxPlayers}</div>
        `;
        div.addEventListener('click', () => {
            document.querySelectorAll('.server-item').forEach(s => s.classList.remove('selected'));
            div.classList.add('selected');
        });
        list.appendChild(div);
    });
}

// ==================== HOTBAR ====================
function createHotbar() {
    const hotbar = document.getElementById('hotbar');
    hotbar.innerHTML = '';
    
    for (let i = 0; i < 9; i++) {
        const slot = document.createElement('div');
        slot.className = 'hotbar-slot' + (i === 0 ? ' selected' : '');
        slot.innerHTML = `
            <span class="slot-number">${i + 1}</span>
            <span class="item-icon"></span>
            <span class="item-count"></span>
        `;
        slot.addEventListener('click', () => {
            Game.selectedSlot = i;
            Game.socket.emit('selectSlot', i);
            updateHotbar();
        });
        hotbar.appendChild(slot);
    }
}

function updateHotbar() {
    if (!Game.player?.hotbar) return;
    
    const slots = document.querySelectorAll('.hotbar-slot');
    const itemIcons = {
        'pickaxe': '‚õèÔ∏è',
        'sword': 'üó°Ô∏è',
        'bow': 'üèπ',
        'gun': 'üî´',
        'torch': 'üî¶',
        'wood': 'ü™µ',
        'stone': 'ü™®',
        'dirt': 'üü´',
        'health_potion': '‚ù§Ô∏è',
        'block': '‚¨ú'
    };
    
    slots.forEach((slot, i) => {
        const item = Game.player.hotbar[i];
        const icon = slot.querySelector('.item-icon');
        const count = slot.querySelector('.item-count');
        
        slot.classList.toggle('selected', i === Game.selectedSlot);
        
        if (item) {
            icon.textContent = itemIcons[item.type] || '‚ùì';
            count.textContent = item.amount > 1 ? item.amount : '';
        } else {
            icon.textContent = '';
            count.textContent = '';
        }
    });
}

// ==================== UI ====================
function updateUI() {
    if (!Game.player) return;
    
    // HP
    const hpPercent = (Game.player.hp / Game.player.maxHp) * 100;
    document.getElementById('healthFill').style.width = hpPercent + '%';
    document.getElementById('healthText').textContent = `${Math.ceil(Game.player.hp)}/${Game.player.maxHp}`;
    
    // XP
    const xpNeeded = 100 * Math.pow(1.5, Game.player.level - 1);
    const xpPercent = (Game.player.xp / xpNeeded) * 100;
    document.getElementById('xpFill').style.width = xpPercent + '%';
    document.getElementById('levelText').textContent = `Lv.${Game.player.level}`;
    
    // Wave
    document.getElementById('waveNumber').textContent = Game.wave;
    document.getElementById('waveTimer').textContent = Math.ceil(Game.waveTimer);
    
    // Tempo
    const isDay = Game.dayTime >= 0.25 && Game.dayTime <= 0.75;
    document.getElementById('timeIcon').textContent = isDay ? '‚òÄÔ∏è' : 'üåô';
    document.getElementById('timeText').textContent = isDay ? 'Dia' : 'Noite';
}

// ==================== CHAT ====================
function toggleChat() {
    Game.chatOpen = !Game.chatOpen;
    const input = document.getElementById('chatInput');
    
    if (Game.chatOpen) {
        input.focus();
    } else {
        input.blur();
    }
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();
    
    if (message) {
        Game.socket.emit('chatMessage', message);
        input.value = '';
    }
    
    toggleChat();
}

function addChatMessage(name, text, color = '#ffffff') {
    const container = document.getElementById('chatMessages');
    const msg = document.createElement('div');
    msg.className = 'chat-message';
    msg.innerHTML = `<span class="name" style="color: ${color}">${name}:</span> <span class="text">${text}</span>`;
    container.appendChild(msg);
    container.scrollTop = container.scrollHeight;
    
    // Remove mensagens antigas
    while (container.children.length > 50) {
        container.removeChild(container.firstChild);
    }
}

function showNotification(text, type = '') {
    const notif = document.createElement('div');
    notif.className = 'notification ' + type;
    notif.textContent = text;
    document.body.appendChild(notif);
    
    setTimeout(() => notif.remove(), 3000);
}

function addDamageNumber(x, y, damage, color) {
    Game.damageNumbers.push({
        x, y,
        text: '-' + Math.ceil(damage),
        color,
        life: 1,
        vy: -2
    });
}
    // ==================== ILUMINA√á√ÉO ====================
function createLightMap() {
    if (!Game.world) return;
    
    Game.lightMap = [];
    for (let x = 0; x < Game.world.width; x++) {
        Game.lightMap[x] = [];
        for (let y = 0; y < Game.world.height; y++) {
            Game.lightMap[x][y] = 0;
        }
    }
    
    // Ilumina√ß√£o inicial do c√©u
    for (let x = 0; x < Game.world.width; x++) {
        let sunlight = 15;
        for (let y = 0; y < Game.world.height; y++) {
            const tile = Game.world.tiles[x][y];
            if (tile !== 0 && TILE_COLORS[tile]) {
                sunlight = Math.max(0, sunlight - 1);
            }
            Game.lightMap[x][y] = sunlight;
        }
    }
}

function updateLocalLight(cx, cy) {
    // Atualiza luz em √°rea ao redor do bloco modificado
    const radius = 15;
    for (let x = cx - radius; x <= cx + radius; x++) {
        if (x < 0 || x >= Game.world.width) continue;
        let sunlight = 15;
        for (let y = 0; y < Game.world.height; y++) {
            const tile = Game.world.tiles[x][y];
            if (tile !== 0 && TILE_COLORS[tile]) {
                sunlight = Math.max(0, sunlight - 1);
            }
            
            // Tochas e outras fontes de luz
            if (tile === 15) { // TORCH
                sunlight = Math.max(sunlight, 14);
            } else if (tile === 12) { // LAVA
                sunlight = Math.max(sunlight, 15);
            }
            
            if (Game.lightMap[x]) {
                Game.lightMap[x][y] = sunlight;
            }
        }
    }
}

// ==================== PART√çCULAS ====================
function createBlockParticles(x, y) {
    for (let i = 0; i < 8; i++) {
        Game.particles.push({
            x: x + Math.random() * CONFIG.TILE_SIZE,
            y: y + Math.random() * CONFIG.TILE_SIZE,
            vx: (Math.random() - 0.5) * 4,
            vy: -Math.random() * 4,
            size: 2 + Math.random() * 3,
            color: '#8B5A2B',
            life: 0.5 + Math.random() * 0.5,
            gravity: 0.3
        });
    }
}

function updateParticles(dt) {
    for (let i = Game.particles.length - 1; i >= 0; i--) {
        const p = Game.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity || 0;
        p.life -= dt;
        
        if (p.life <= 0) {
            Game.particles.splice(i, 1);
        }
    }
    
    // Limita part√≠culas
    while (Game.particles.length > CONFIG.PARTICLE_LIMIT) {
        Game.particles.shift();
    }
    
    // N√∫meros de dano
    for (let i = Game.damageNumbers.length - 1; i >= 0; i--) {
        const d = Game.damageNumbers[i];
        d.y += d.vy;
        d.life -= dt;
        
        if (d.life <= 0) {
            Game.damageNumbers.splice(i, 1);
        }
    }
}

// ==================== RENDERIZA√á√ÉO ====================
function render() {
    const ctx = Game.ctx;
    const width = Game.canvas.width;
    const height = Game.canvas.height;
    
    // Limpa canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
    
    if (!Game.playing || !Game.world) return;
    
    // Atualiza c√¢mera
    updateCamera();
    
    // Aplica shake
    const shakeX = Game.camera.shakeX || 0;
    const shakeY = Game.camera.shakeY || 0;
    Game.camera.shakeX = shakeX * 0.9;
    Game.camera.shakeY = shakeY * 0.9;
    
    ctx.save();
    ctx.translate(-Game.camera.x + shakeX, -Game.camera.y + shakeY);
    
    // Renderiza parallax background
    renderSky(ctx);
    
    // Renderiza mundo
    renderWorld(ctx);
    
    // Renderiza itens
    renderItems(ctx);
    
    // Renderiza jogadores
    renderPlayers(ctx);
    
    // Renderiza zumbis
    renderZombies(ctx);
    
    // Renderiza proj√©teis
    renderProjectiles(ctx);
    
    // Renderiza part√≠culas
    renderParticles(ctx);
    
    // Highlight do bloco sob o mouse
    renderBlockHighlight(ctx);
    
    ctx.restore();
    
    // Renderiza n√∫meros de dano (UI space)
    renderDamageNumbers(ctx);
    
    // Efeito de dano
    if (Game.damageFlash > 0) {
        ctx.fillStyle = `rgba(255, 0, 0, ${Game.damageFlash * 0.3})`;
        ctx.fillRect(0, 0, width, height);
        Game.damageFlash -= 0.05;
    }
    
    // FPS
    if (CONFIG.SHOW_FPS) {
        ctx.fillStyle = '#fff';
        ctx.font = '14px monospace';
        ctx.fillText(`FPS: ${Game.fps}`, 10, height - 10);
    }
    
    // Renderiza minimap
    renderMinimap();
}

function updateCamera() {
    if (!Game.player) return;
    
    const targetX = Game.player.x - Game.canvas.width / 2;
    const targetY = Game.player.y - Game.canvas.height / 2;
    
    // Suaviza movimento da c√¢mera
    Game.camera.x += (targetX - Game.camera.x) * 0.1;
    Game.camera.y += (targetY - Game.camera.y) * 0.1;
    
    // Limites do mundo
    const maxX = Game.world.width * CONFIG.TILE_SIZE - Game.canvas.width;
    const maxY = Game.world.height * CONFIG.TILE_SIZE - Game.canvas.height;
    
    Game.camera.x = Math.max(0, Math.min(maxX, Game.camera.x));
    Game.camera.y = Math.max(0, Math.min(maxY, Game.camera.y));
}

function renderSky(ctx) {
    const width = Game.canvas.width;
    const height = Game.canvas.height;
    
    // Cor do c√©u baseada no tempo
    let skyTop, skyBottom;
    
    if (Game.dayTime < 0.25) {
        // Noite -> Amanhecer
        const t = Game.dayTime / 0.25;
        skyTop = lerpColor('#0a0a2e', '#ff7e50', t);
        skyBottom = lerpColor('#1a1a3e', '#ffb347', t);
    } else if (Game.dayTime < 0.5) {
        // Amanhecer -> Meio-dia
        const t = (Game.dayTime - 0.25) / 0.25;
        skyTop = lerpColor('#ff7e50', '#4a90d9', t);
        skyBottom = lerpColor('#ffb347', '#87CEEB', t);
    } else if (Game.dayTime < 0.75) {
        // Meio-dia -> Entardecer
        const t = (Game.dayTime - 0.5) / 0.25;
        skyTop = lerpColor('#4a90d9', '#ff6b35', t);
        skyBottom = lerpColor('#87CEEB', '#ff8c42', t);
    } else {
        // Entardecer -> Noite
        const t = (Game.dayTime - 0.75) / 0.25;
        skyTop = lerpColor('#ff6b35', '#0a0a2e', t);
        skyBottom = lerpColor('#ff8c42', '#1a1a3e', t);
    }
    
    // Gradiente do c√©u
    const gradient = ctx.createLinearGradient(0, Game.camera.y, 0, Game.camera.y + height);
    gradient.addColorStop(0, skyTop);
    gradient.addColorStop(1, skyBottom);
    
    ctx.fillStyle = gradient;
    ctx.fillRect(Game.camera.x, Game.camera.y, width, height);
    
    // Sol/Lua
    const celestialY = Game.camera.y + height * 0.2;
    const celestialX = Game.camera.x + width * (0.2 + Game.dayTime * 0.6);
    
    if (Game.dayTime >= 0.25 && Game.dayTime <= 0.75) {
        // Sol
        ctx.fillStyle = '#FFD700';
        ctx.beginPath();
        ctx.arc(celestialX, celestialY, 40, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#FFF8DC';
        ctx.beginPath();
        ctx.arc(celestialX, celestialY, 35, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Lua
        ctx.fillStyle = '#F5F5F5';
        ctx.beginPath();
        ctx.arc(celestialX, celestialY, 30, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#E0E0E0';
        ctx.beginPath();
        ctx.arc(celestialX - 5, celestialY - 5, 8, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Estrelas √† noite
    if (Game.dayTime < 0.25 || Game.dayTime > 0.75) {
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 50; i++) {
            const starX = Game.camera.x + ((i * 137) % width);
            const starY = Game.camera.y + ((i * 251) % (height * 0.5));
            const size = 1 + (i % 3);
            const alpha = 0.3 + Math.sin(Date.now() / 500 + i) * 0.3;
            ctx.globalAlpha = alpha;
            ctx.fillRect(starX, starY, size, size);
        }
        ctx.globalAlpha = 1;
    }
    
    // Montanhas de fundo (parallax)
    renderMountains(ctx);
    
    // Nuvens
    renderClouds(ctx);
}

function renderMountains(ctx) {
    const parallax = 0.3;
    const baseY = Game.camera.y + Game.canvas.height * 0.6;
    
    ctx.fillStyle = '#2d4a3e';
    ctx.beginPath();
    ctx.moveTo(Game.camera.x, baseY + 200);
    
    for (let x = 0; x <= Game.canvas.width + 100; x += 50) {
        const worldX = (Game.camera.x * parallax + x);
        const peakHeight = Math.sin(worldX * 0.005) * 100 + Math.sin(worldX * 0.01) * 50;
        ctx.lineTo(Game.camera.x + x, baseY - peakHeight);
    }
    
    ctx.lineTo(Game.camera.x + Game.canvas.width, baseY + 200);
    ctx.closePath();
    ctx.fill();
    
    // Segunda camada
    ctx.fillStyle = '#1a3025';
    ctx.beginPath();
    ctx.moveTo(Game.camera.x, baseY + 200);
    
    for (let x = 0; x <= Game.canvas.width + 100; x += 40) {
        const worldX = (Game.camera.x * (parallax * 0.6) + x);
        const peakHeight = Math.sin(worldX * 0.008 + 1) * 80 + Math.sin(worldX * 0.015) * 40 + 50;
        ctx.lineTo(Game.camera.x + x, baseY - peakHeight);
    }
    
    ctx.lineTo(Game.camera.x + Game.canvas.width, baseY + 200);
    ctx.closePath();
    ctx.fill();
}

function renderClouds(ctx) {
    const cloudY = Game.camera.y + 100;
    const time = Date.now() / 20000;
    
    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
    
    for (let i = 0; i < 10; i++) {
        const baseX = ((i * 300 + time * 100 * (1 + i % 3)) % (Game.canvas.width + 400)) - 200;
        const x = Game.camera.x + baseX;
        const y = cloudY + Math.sin(i * 1.5) * 50;
        
        // Nuvem = v√°rios c√≠rculos
        for (let j = 0; j < 5; j++) {
            const cx = x + j * 25 - 50;
            const cy = y + Math.sin(j) * 10;
            const r = 30 + Math.sin(j * 2) * 10;
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}

function renderWorld(ctx) {
    const startX = Math.floor(Game.camera.x / CONFIG.TILE_SIZE) - 1;
    const startY = Math.floor(Game.camera.y / CONFIG.TILE_SIZE) - 1;
    const endX = startX + Math.ceil(Game.canvas.width / CONFIG.TILE_SIZE) + 2;
    const endY = startY + Math.ceil(Game.canvas.height / CONFIG.TILE_SIZE) + 2;
    
    const ts = CONFIG.TILE_SIZE;
    
    // Background tiles primeiro
    for (let x = startX; x <= endX; x++) {
        for (let y = startY; y <= endY; y++) {
            if (x < 0 || x >= Game.world.width || y < 0 || y >= Game.world.height) continue;
            
            const bgTile = Game.world.background[x][y];
            if (bgTile && TILE_COLORS[bgTile]) {
                const colors = TILE_COLORS[bgTile];
                ctx.fillStyle = colors[0];
                ctx.globalAlpha = 0.5;
                ctx.fillRect(x * ts, y * ts, ts, ts);
                ctx.globalAlpha = 1;
            }
        }
    }
    
    // Foreground tiles
    for (let x = startX; x <= endX; x++) {
        for (let y = startY; y <= endY; y++) {
            if (x < 0 || x >= Game.world.width || y < 0 || y >= Game.world.height) continue;
            
            const tile = Game.world.tiles[x][y];
            if (!tile || !TILE_COLORS[tile]) continue;
            
            const colors = TILE_COLORS[tile];
            
            // Cor base
            ctx.fillStyle = colors[0];
            ctx.fillRect(x * ts, y * ts, ts, ts);
            
            // Detalhes do tile
            renderTileDetails(ctx, x, y, tile, colors);
            
            // Ilumina√ß√£o
            const light = Game.lightMap?.[x]?.[y] ?? 15;
            const darkness = 1 - (light / 15);
            const nightFactor = (Game.dayTime < 0.25 || Game.dayTime > 0.75) ? 0.3 : 0;
            const totalDarkness = Math.min(0.95, darkness * 0.7 + nightFactor);
            
            if (totalDarkness > 0) {
                ctx.fillStyle = `rgba(0, 0, 0, ${totalDarkness})`;
                ctx.fillRect(x * ts, y * ts, ts, ts);
            }
        }
    }
}

function renderTileDetails(ctx, x, y, tile, colors) {
    const ts = CONFIG.TILE_SIZE;
    const px = x * ts;
    const py = y * ts;
    
    switch (tile) {
        case 2: // GRASS
            // Grama no topo
            ctx.fillStyle = '#5cbf60';
            ctx.fillRect(px, py, ts, 3);
            // Textura
            ctx.fillStyle = colors[1];
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(px + i * 5 + 2, py + 3, 2, 2);
            }
            break;
            
        case 3: // STONE
        case 13: // COBBLESTONE
            // Textura de pedra
            ctx.fillStyle = colors[1];
            ctx.fillRect(px + 2, py + 2, 4, 4);
            ctx.fillRect(px + 10, py + 8, 4, 5);
            ctx.fillStyle = colors[2];
            ctx.fillRect(px + 7, py + 4, 3, 3);
            break;
            
        case 6: // COAL
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(px + 4, py + 4, 4, 4);
            ctx.fillRect(px + 9, py + 7, 3, 3);
            ctx.fillRect(px + 3, py + 10, 4, 3);
            break;
            
        case 7: // IRON
            ctx.fillStyle = '#e8d4b8';
            ctx.fillRect(px + 3, py + 3, 4, 4);
            ctx.fillRect(px + 9, py + 8, 4, 4);
            break;
            
        case 8: // GOLD
            ctx.fillStyle = '#fff44f';
            ctx.fillRect(px + 4, py + 4, 5, 5);
            ctx.fillRect(px + 8, py + 9, 4, 4);
            break;
            
        case 9: // DIAMOND
            ctx.fillStyle = '#7DF9FF';
            ctx.beginPath();
            ctx.moveTo(px + 8, py + 3);
            ctx.lineTo(px + 12, py + 8);
            ctx.lineTo(px + 8, py + 13);
            ctx.lineTo(px + 4, py + 8);
            ctx.closePath();
            ctx.fill();
            break;
            
        case 15: // TORCH
            // Vara
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(px + 6, py + 6, 4, 10);
            // Chama
            const flicker = Math.sin(Date.now() / 100 + x) * 2;
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.arc(px + 8, py + 4 + flicker, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(px + 8, py + 4 + flicker, 2, 0, Math.PI * 2);
            ctx.fill();
            break;
            
        case 4: // WOOD
            // Textura de madeira
            ctx.fillStyle = colors[1];
            ctx.fillRect(px, py + 4, ts, 2);
            ctx.fillRect(px, py + 10, ts, 2);
            break;
            
        case 5: // LEAVES
            // Textura de folhas
            ctx.fillStyle = colors[1];
            for (let i = 0; i < 4; i++) {
                const lx = px + Math.random() * 12;
                const ly = py + Math.random() * 12;
                ctx.fillRect(lx, ly, 4, 4);
            }
            break;
    }
}

function renderItems(ctx) {
    Game.items.forEach((item) => {
        const bob = Math.sin(Date.now() / 300 + item.x) * 3;
        
        ctx.save();
        ctx.translate(item.x, item.y + bob);
        
        // Brilho
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // √çcone
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        const icons = {
            'xp': '‚ú®',
            'coin': 'ü™ô',
            'health_potion': '‚ù§Ô∏è',
            'ammo': 'üîπ',
            'block': '‚¨ú'
        };
        
        ctx.fillText(icons[item.type] || '‚ùì', 0, 0);
        
        ctx.restore();
    });
}

function renderPlayers(ctx) {
    Game.players.forEach((player) => {
        renderPlayer(ctx, player, player.id === Game.playerId);
    });
}

function renderPlayer(ctx, player, isLocal) {
    const x = player.x;
    const y = player.y;
    const w = player.width || 24;
    const h = player.height || 40;
    
    ctx.save();
    ctx.translate(x, y);
    
    // Flip se olhando para esquerda
    if (!player.facingRight) {
        ctx.scale(-1, 1);
    }
    
    // Sombra
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(0, h/2 - 2, w/2, 5, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Corpo
    ctx.fillStyle = player.color || '#00ff44';
    ctx.fillRect(-w/2 + 4, -h/2 + 15, w - 8, h - 20);
    
    // Cabe√ßa
    ctx.fillStyle = '#FFE4C4';
    ctx.fillRect(-w/2 + 2, -h/2, w - 4, 18);
    
    // Olhos
    ctx.fillStyle = '#000';
    ctx.fillRect(-w/2 + 6, -h/2 + 6, 4, 4);
    ctx.fillRect(w/2 - 10, -h/2 + 6, 4, 4);
    
    // Cabelo
    ctx.fillStyle = player.color || '#00ff44';
    ctx.fillRect(-w/2 + 2, -h/2, w - 4, 5);
    
    // Pernas (anima√ß√£o de andar)
    const walkAnim = Math.abs(player.vx) > 0.1 ? Math.sin(Date.now() / 100) * 5 : 0;
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(-w/2 + 4, h/2 - 12, 6, 10);
    ctx.fillRect(w/2 - 10, h/2 - 12, 6, 10);
    
    // Bra√ßo com arma
    ctx.fillStyle = '#FFE4C4';
    const armY = -h/2 + 20;
    ctx.fillRect(w/2 - 4, armY, 8, 15);
    
    // Arma
    const item = player.selectedSlot !== undefined && player.hotbar ? 
                 player.hotbar[player.selectedSlot] : null;
    if (item) {
        ctx.font = '16px Arial';
        ctx.fillText(getItemIcon(item.type), w/2 + 8, armY + 8);
    }
    
    ctx.restore();
    
    // Nome e barra de HP
    ctx.fillStyle = '#fff';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(player.name, x, y - h/2 - 20);
    
    // HP bar
    const hpWidth = 40;
    const hpHeight = 6;
    const hpX = x - hpWidth/2;
    const hpY = y - h/2 - 12;
    
    ctx.fillStyle = '#333';
    ctx.fillRect(hpX, hpY, hpWidth, hpHeight);
    ctx.fillStyle = '#ff4444';
    ctx.fillRect(hpX, hpY, hpWidth * (player.hp / player.maxHp), hpHeight);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(hpX, hpY, hpWidth, hpHeight);
}

function renderZombies(ctx) {
    Game.zombies.forEach((zombie) => {
        renderZombie(ctx, zombie);
    });
}

function renderZombie(ctx, zombie) {
    const x = zombie.x;
    const y = zombie.y;
    const w = zombie.width || 24;
    const h = zombie.height || 40;
    
    ctx.save();
    ctx.translate(x, y);
    
    if (!zombie.facingRight) {
        ctx.scale(-1, 1);
    }
    
    // Cores baseadas no tipo
    const colors = {
        normal: { body: '#2d5a27', skin: '#5a8f54' },
        fast: { body: '#1a3a17', skin: '#3d6a37' },
        tank: { body: '#4a2a4a', skin: '#7a5a7a' },
        crawler: { body: '#3a2a1a', skin: '#5a4a3a' },
        giant: { body: '#5a0000', skin: '#8a3030' },
        necromancer: { body: '#2a0a3a', skin: '#5a3a6a' },
        berserker: { body: '#5a2a0a', skin: '#8a5a3a' }
    };
    
    const c = colors[zombie.type] || colors.normal;
    
    if (zombie.isBoss) {
        // Aura de boss
        ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.arc(0, 0, 60, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Corpo do zumbi
    ctx.fillStyle = c.body;
    ctx.fillRect(-w/2 + 2, -h/2 + 12, w - 4, h - 15);
    
    // Cabe√ßa
    ctx.fillStyle = c.skin;
    ctx.fillRect(-w/2, -h/2, w, 16);
    
    // Olhos vermelhos
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(-w/2 + 4, -h/2 + 5, 4, 4);
    ctx.fillRect(w/2 - 8, -h/2 + 5, 4, 4);
    
    // Boca
    ctx.fillStyle = '#300';
    ctx.fillRect(-w/2 + 4, -h/2 + 11, w - 8, 3);
    
    // Bra√ßos (anima√ß√£o)
    const armAnim = Math.sin(Date.now() / 200) * 10;
    ctx.fillStyle = c.skin;
    ctx.save();
    ctx.translate(-w/2, -h/2 + 15);
    ctx.rotate((-20 + armAnim) * Math.PI / 180);
    ctx.fillRect(-4, 0, 6, 20);
    ctx.restore();
    
    ctx.save();
    ctx.translate(w/2, -h/2 + 15);
    ctx.rotate((20 - armAnim) * Math.PI / 180);
    ctx.fillRect(-2, 0, 6, 20);
    ctx.restore();
    
    // Pernas
    const legAnim = Math.sin(Date.now() / 150) * 8;
    ctx.fillStyle = c.body;
    ctx.fillRect(-w/2 + 2, h/2 - 15, 8, 12);
    ctx.fillRect(w/2 - 10, h/2 - 15, 8, 12);
    
    ctx.restore();
    
    // HP bar do boss
    if (zombie.isBoss) {
        const hpWidth = 80;
        const hpHeight = 10;
        const hpX = x - hpWidth/2;
        const hpY = y - h/2 - 25;
        
        ctx.fillStyle = '#333';
        ctx.fillRect(hpX, hpY, hpWidth, hpHeight);
        ctx.fillStyle = '#ff00ff';
        ctx.fillRect(hpX, hpY, hpWidth * (zombie.hp / zombie.maxHp), hpHeight);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(hpX, hpY, hpWidth, hpHeight);
        
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('BOSS', x, hpY - 5);
    }
}

function renderProjectiles(ctx) {
    Game.projectiles.forEach((proj) => {
        ctx.save();
        ctx.translate(proj.x, proj.y);
        ctx.rotate(Math.atan2(proj.vy, proj.vx));
        
        if (proj.type === 'bullet') {
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(-8, -2, 16, 4);
        } else if (proj.type === 'arrow') {
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-15, -1, 20, 2);
            ctx.fillStyle = '#808080';
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(5, -4);
            ctx.lineTo(5, 4);
            ctx.closePath();
            ctx.fill();
        }
        
        ctx.restore();
    });
}

function renderParticles(ctx) {
    Game.particles.forEach((p) => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
    });
    ctx.globalAlpha = 1;
}

function renderBlockHighlight(ctx) {
    if (!Game.mouse.x || !Game.mouse.y) return;
    
    const worldX = Game.mouse.x + Game.camera.x;
    const worldY = Game.mouse.y + Game.camera.y;
    const tileX = Math.floor(worldX / CONFIG.TILE_SIZE);
    const tileY = Math.floor(worldY / CONFIG.TILE_SIZE);
    
    // Verifica dist√¢ncia
    const dist = Math.hypot(
        tileX * CONFIG.TILE_SIZE + 8 - Game.player.x,
        tileY * CONFIG.TILE_SIZE + 8 - Game.player.y
    );
    
    if (dist <= 100) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(
            tileX * CONFIG.TILE_SIZE,
            tileY * CONFIG.TILE_SIZE,
            CONFIG.TILE_SIZE,
            CONFIG.TILE_SIZE
        );
    }
}

function renderDamageNumbers(ctx) {
    Game.damageNumbers.forEach((d) => {
        const screenX = d.x - Game.camera.x;
        const screenY = d.y - Game.camera.y;
        
        ctx.globalAlpha = d.life;
        ctx.fillStyle = d.color;
        ctx.font = 'bold 18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(d.text, screenX, screenY);
    });
    ctx.globalAlpha = 1;
}

function renderMinimap() {
    const ctx = Game.minimapCtx;
    const width = Game.minimapCanvas.width;
    const height = Game.minimapCanvas.height;
    
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, width, height);
    
    if (!Game.world || !Game.player) return;
    
    const scale = 0.5;
    const centerX = Game.player.x / CONFIG.TILE_SIZE;
    const centerY = Game.player.y / CONFIG.TILE_SIZE;
    const viewWidth = width / scale;
    const viewHeight = height / scale;
    
    const startX = Math.floor(centerX - viewWidth / 2);
    const startY = Math.floor(centerY - viewHeight / 2);
    
    // Tiles
    for (let x = 0; x < viewWidth; x++) {
        for (let y = 0; y < viewHeight; y++) {
            const wx = startX + x;
            const wy = startY + y;
            
            if (wx < 0 || wx >= Game.world.width || wy < 0 || wy >= Game.world.height) continue;
            
            const tile = Game.world.tiles[wx][wy];
            if (tile && TILE_COLORS[tile]) {
                ctx.fillStyle = TILE_COLORS[tile][0];
                ctx.fillRect(x * scale, y * scale, scale, scale);
            }
        }
    }
    
    // Jogador
    ctx.fillStyle = '#00ff44';
    ctx.fillRect(
        (centerX - startX) * scale - 2,
        (centerY - startY) * scale - 2,
        4, 4
    );
    
    // Outros jogadores
    ctx.fillStyle = '#4444ff';
    Game.players.forEach((p) => {
        if (p.id === Game.playerId) return;
        const px = p.x / CONFIG.TILE_SIZE - startX;
        const py = p.y / CONFIG.TILE_SIZE - startY;
        ctx.fillRect(px * scale - 1, py * scale - 1, 3, 3);
    });
    
    // Zumbis
    ctx.fillStyle = '#ff4444';
    Game.zombies.forEach((z) => {
        const zx = z.x / CONFIG.TILE_SIZE - startX;
        const zy = z.y / CONFIG.TILE_SIZE - startY;
        ctx.fillRect(zx * scale - 1, zy * scale - 1, 2, 2);
    });
}

// ==================== UTILIDADES ====================
function lerpColor(color1, color2, t) {
    const c1 = hexToRgb(color1);
    const c2 = hexToRgb(color2);
    
    const r = Math.round(c1.r + (c2.r - c1.r) * t);
    const g = Math.round(c1.g + (c2.g - c1.g) * t);
    const b = Math.round(c1.b + (c2.b - c1.b) * t);
    
    return `rgb(${r}, ${g}, ${b})`;
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : { r: 0, g: 0, b: 0 };
}

function getItemIcon(type) {
    const icons = {
        'pickaxe': '‚õèÔ∏è',
        'sword': 'üó°Ô∏è',
        'bow': 'üèπ',
        'gun': 'üî´',
        'torch': 'üî¶',
        'wood': 'ü™µ',
        'stone': 'ü™®',
        'health_potion': '‚ù§Ô∏è'
    };
    return icons[type] || '‚ùì';
}

// ==================== GAME LOOP ====================
function gameLoop(timestamp) {
    const dt = (timestamp - Game.lastUpdate) / 1000;
    Game.lastUpdate = timestamp;
    
    // FPS counter
    Game.frameCount++;
    if (timestamp - Game.lastFpsUpdate >= 1000) {
        Game.fps = Game.frameCount;
        Game.frameCount = 0;
        Game.lastFpsUpdate = timestamp;
    }
    
    // Update
    if (Game.playing) {
        updateInput();
        updateParticles(dt);
    }
    
    // Render
    render();
    
    requestAnimationFrame(gameLoop);
}

function updateInput() {
    if (!Game.player) return;
    
    const input = {
        left: Game.keys['KeyA'] || Game.keys['ArrowLeft'] || Game.joystick.left.x < -0.3,
        right: Game.keys['KeyD'] || Game.keys['ArrowRight'] || Game.joystick.left.x > 0.3,
        jump: Game.keys['Space'] || Game.keys['KeyW'] || Game.keys['ArrowUp'] || Game.joystick.left.y < -0.5
    };
    
    Game.socket.emit('playerInput', input);
    
    // Auto-ataque cont√≠nuo
    if (Game.mouse.down && Game.playing) {
        const worldX = Game.mouse.x + Game.camera.x;
        const worldY = Game.mouse.y + Game.camera.y;
        
        const item = Game.player.hotbar?.[Game.selectedSlot];
        if (item?.type === 'pickaxe') {
            Game.socket.emit('playerAction', { type: 'break', x: worldX, y: worldY });
        }
    }
}

// ==================== INICIALIZA√á√ÉO ====================
window.addEventListener('load', init);
</script>
