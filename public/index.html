<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>RPG Legends: Reborn</title>
<style>
* { box-sizing: border-box; touch-action: none; user-select: none; font-family: sans-serif; }
body { margin: 0; background: #1a1a1a; overflow: hidden; color: white; }

.screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #000; z-index: 100; }
.hidden { display: none !important; }

h1 { color: #ffd700; text-shadow: 0 0 10px #f00; font-size: 2rem; text-align: center; }
input { background: #333; border: 1px solid #555; color: #fff; padding: 10px; font-size: 16px; border-radius: 5px; text-align: center; margin: 10px; }
button { background: #2e8b57; color: white; border: none; padding: 12px 25px; font-size: 16px; font-weight: bold; border-radius: 5px; margin-top: 5px; cursor: pointer; }

#hud { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; display: none; }
.top-bar { position: absolute; top: 10px; left: 10px; }
.bar-con { width: 150px; height: 15px; background: #222; border: 1px solid #555; margin-bottom: 2px; position: relative; }
.fill { height: 100%; } .hp { background: #f44; } .xp { background: #48f; }

.inv { position: absolute; top: 10px; right: 10px; display: flex; gap: 5px; }
.slot { background: rgba(0,0,0,0.5); padding: 5px; border: 1px solid #555; font-size: 12px; }

#buildBtn { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background: #d35400; padding: 10px; pointer-events: auto; display: none; }

#levelScreen { background: rgba(0,0,0,0.9); z-index: 200; }
.cards { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
.card { background: #333; border: 2px solid #fd0; padding: 10px; width: 100px; text-align: center; pointer-events: auto; }

#deathScreen { background: rgba(50,0,0,0.9); z-index: 150; }

#minimap { position: absolute; top: 50px; right: 10px; background: #000; border: 1px solid #fff; opacity: 0.7; }
canvas { display: block; }
</style>
</head>
<body>

<div id="menuScreen" class="screen">
    <h1>RPG LEGENDS</h1>
    <input id="playerName" placeholder="Nome do Heroi">
    <button id="createBtn">CRIAR MUNDO</button>
    <div style="margin:5px; color:#888">- ou -</div>
    <input id="roomInput" placeholder="CODIGO">
    <button id="joinBtn">ENTRAR</button>
</div>

<div id="hud">
    <div class="top-bar">
        <div class="bar-con"><div id="hpBar" class="fill hp" style="width:100%"></div></div>
        <div class="bar-con"><div id="xpBar" class="fill xp" style="width:0%"></div></div>
    </div>
    <div class="inv">
        <div class="slot">ü™µ <span id="wd">0</span></div>
        <div class="slot">ü™® <span id="st">0</span></div>
    </div>
    <button id="buildBtn" onclick="buildWall()">üî® PAREDE (10)</button>
    <canvas id="minimap" width="100" height="100"></canvas>
</div>

<div id="levelScreen" class="screen hidden">
    <h2 style="color:#fd0">LEVEL UP!</h2>
    <div class="cards">
        <div class="card" onclick="up('dmg')">‚öîÔ∏è<br>Dano</div>
        <div class="card" onclick="up('hp')">‚ù§Ô∏è<br>Vida</div>
        <div class="card" onclick="up('spd')">‚ö°<br>Speed</div>
    </div>
</div>

<div id="deathScreen" class="screen hidden">
    <h1 style="color:red">MORREU</h1>
    <button onclick="respawn()">RENASCER</button>
</div>

<canvas id="game"></canvas>

<script src="/socket.io/socket.io.js"></script>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const mCtx = document.getElementById("minimap").getContext("2d");
let socket = io();
let myId = null, roomId = null;
let camera = { x: 0, y: 0 };
// INICIA O PLAYER COM VALORES SEGUROS PRA N√ÉO SUMIR
let localPlayer = { x: 1200, y: 1200, hp: 100, maxHp: 100, role: 'warrior' };
let state = { players: {}, enemies: [], resources: [], buildings: [], xpOrbs: [] };
let joyL = { on: false, id: null, dx: 0, dy: 0, ox: 0, oy: 0 };
let joyR = { on: false, id: null, dx: 0, dy: 0, ox: 0, oy: 0, ang: 0 };
let damage = [];

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize(); window.addEventListener("resize", resize);

document.getElementById('createBtn').onclick = () => {
    socket.emit('createRoom', document.getElementById('playerName').value || "Heroi");
}
document.getElementById('joinBtn').onclick = () => {
    const code = document.getElementById('roomInput').value.trim().toUpperCase();
    if(code) socket.emit('joinRoom', { code: code, name: document.getElementById('playerName').value || "Visitante" });
}

const start = (code) => {
    roomId = code;
    document.getElementById('menuScreen').classList.add('hidden');
    document.getElementById('hud').style.display = 'block';
}

socket.on('roomCreated', start);
socket.on('joinedRoom', start);
socket.on('connect', () => myId = socket.id);

socket.on('updateWorld', (data) => {
    state = data;
    if(state.players[myId]) {
        // Atualiza localPlayer mas mant√©m X/Y suaves se quiser (aqui atualiza direto)
        const s = state.players[myId];
        localPlayer.hp = s.hp; localPlayer.maxHp = s.maxHp; 
        localPlayer.xp = s.xp; localPlayer.level = s.level;
        localPlayer.inv = s.inv; localPlayer.dead = s.dead;
        localPlayer.nextLevel = s.nextLevel;
        
        // HUD
        document.getElementById('hpBar').style.width = (s.hp/s.maxHp*100)+'%';
        document.getElementById('xpBar').style.width = (s.xp/s.nextLevel*100)+'%';
        document.getElementById('wd').innerText = s.inv.wood;
        document.getElementById('st').innerText = s.inv.stone;
        document.getElementById('buildBtn').style.display = s.inv.wood >= 10 ? 'block' : 'none';
        
        if(s.dead) document.getElementById('deathScreen').classList.remove('hidden');
        else document.getElementById('deathScreen').classList.add('hidden');
    }
});

socket.on('levelUp', () => document.getElementById('levelScreen').classList.remove('hidden'));
socket.on('damageEffect', (d) => damage.push({ x: d.x, y: d.y, val: d.dmg, t: 1 }));

// INPUT
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if(t.clientX < window.innerWidth/2 && !joyL.on) {
            joyL.on = true; joyL.id = t.identifier; joyL.ox = t.clientX; joyL.oy = t.clientY;
        } else if(t.clientX > window.innerWidth/2 && !joyR.on) {
            joyR.on = true; joyR.id = t.identifier; joyR.ox = t.clientX; joyR.oy = t.clientY;
        }
    }
}, {passive:false});

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if(t.identifier === joyL.id) {
            const dx = t.clientX - joyL.ox; const dy = t.clientY - joyL.oy;
            const d = Math.min(Math.hypot(dx,dy), 40); const a = Math.atan2(dy, dx);
            joyL.dx = Math.cos(a)*(d/40); joyL.dy = Math.sin(a)*(d/40);
        }
        if(t.identifier === joyR.id) {
            joyR.dx = t.clientX - joyR.ox; joyR.dy = t.clientY - joyR.oy;
            joyR.ang = Math.atan2(joyR.dy, joyR.dx);
        }
    }
}, {passive:false});

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    for(let i=0; i<e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if(t.identifier === joyL.id) { joyL.on=false; joyL.dx=0; joyL.dy=0; }
        if(t.identifier === joyR.id) joyR.on=false;
    }
}, {passive:false});

let lastShot = 0;

function loop() {
    requestAnimationFrame(loop);
    if(!roomId) return;

    let moveState = 'idle';
    let facing = 0;
    
    // MOVIMENTO LOCAL (CLIENT-SIDE PREDICTION)
    if(joyL.on) {
        localPlayer.x += joyL.dx * 5;
        localPlayer.y += joyL.dy * 5;
        // Clamp
        localPlayer.x = Math.max(0, Math.min(2400, localPlayer.x));
        localPlayer.y = Math.max(0, Math.min(2400, localPlayer.y));
        moveState = 'run';
        facing = joyL.dx > 0 ? 1 : -1;
    }

    let aim = localPlayer.aimAngle || 0;
    let shoot = false;

    if(joyR.on) {
        aim = joyR.ang; shoot = true;
    } else {
        // Auto Aim
        let min = 400; let t = null;
        state.enemies.forEach(e => {
            const d = Math.hypot(e.x - localPlayer.x, e.y - localPlayer.y);
            if(d < min) { min = d; t = e; }
        });
        if(t) { aim = Math.atan2(t.y - localPlayer.y, t.x - localPlayer.x); shoot = true; }
    }

    socket.emit('move', { roomId, x: localPlayer.x, y: localPlayer.y, state: moveState, facing, angle: aim });
    
    if(shoot && Date.now() - lastShot > 250) {
        lastShot = Date.now();
        socket.emit('attack', { roomId, angle: aim });
    }

    // Camera
    camera.x += (localPlayer.x - camera.x - canvas.width/2) * 0.1;
    camera.y += (localPlayer.y - camera.y - canvas.height/2) * 0.1;

    // RENDER
    ctx.fillStyle = "#111"; ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.save(); ctx.translate(-camera.x, -camera.y);

    // Grid
    ctx.strokeStyle = "#222"; ctx.lineWidth = 2;
    for(let i=0; i<2400; i+=100) { ctx.strokeRect(i,0,1,2400); ctx.strokeRect(0,i,2400,1); }

    // World
    state.resources.forEach(r => {
        ctx.fillStyle = r.type==='tree' ? '#27ae60' : '#7f8c8d';
        ctx.beginPath(); ctx.arc(r.x, r.y, 15, 0, Math.PI*2); ctx.fill();
        if(r.type==='tree') ctx.fillRect(r.x-5, r.y, 10, 15);
    });

    state.buildings.forEach(b => { ctx.fillStyle="#d35400"; ctx.fillRect(b.x-20, b.y-20, 40, 40); });
    state.xpOrbs.forEach(o => { ctx.fillStyle="#0af"; ctx.beginPath(); ctx.arc(o.x, o.y, 4, 0, Math.PI*2); ctx.fill(); });

    state.enemies.forEach(e => {
        if(e.dead) return;
        ctx.fillStyle = "#c0392b"; ctx.beginPath(); ctx.arc(e.x, e.y, 15, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#0f0"; ctx.fillRect(e.x-15, e.y-25, 30*(e.hp/e.maxHp), 4);
    });

    // Players
    Object.keys(state.players).forEach(id => {
        const p = state.players[id];
        if(p.dead) return;
        // Posi√ß√£o: Se for eu, usa localPlayer, sen√£o usa do server
        const x = id===myId ? localPlayer.x : p.x;
        const y = id===myId ? localPlayer.y : p.y;
        
        ctx.fillStyle = p.role === 'warrior' ? '#3498db' : '#9b59b6';
        ctx.beginPath(); ctx.arc(x, y, 15, 0, Math.PI*2); ctx.fill();
        // Olhos
        ctx.fillStyle="#fff"; ctx.fillRect(x-5, y-5, 4, 4); ctx.fillRect(x+2, y-5, 4, 4);
        // Arma
        ctx.save(); ctx.translate(x, y); ctx.rotate(p.aimAngle||0);
        ctx.fillStyle="#ccc"; ctx.fillRect(10, -3, 20, 6);
        ctx.restore();
        
        ctx.fillStyle="#fff"; ctx.font="10px Arial"; ctx.fillText(p.name, x-10, y-20);
    });

    // VFX
    damage.forEach((d,i) => {
        d.y-=1; d.t-=0.05; ctx.globalAlpha=d.t;
        ctx.fillStyle="#fff"; ctx.font="16px Arial"; ctx.fillText(d.val, d.x, d.y);
        ctx.globalAlpha=1; if(d.t<=0) damage.splice(i,1);
    });

    ctx.restore();

    // UI Draw
    if(joyL.on) {
        ctx.strokeStyle="rgba(255,255,255,0.3)"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(joyL.ox, joyL.oy, 40, 0, 7); ctx.stroke();
        ctx.beginPath(); ctx.arc(joyL.ox+joyL.dx*40, joyL.oy+joyL.dy*40, 20, 0, 7); ctx.stroke();
    }
    if(joyR.on) {
        ctx.strokeStyle="rgba(255,50,50,0.3)"; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(joyR.ox, joyR.oy, 40, 0, 7); ctx.stroke();
        ctx.beginPath(); ctx.arc(joyR.ox+Math.cos(joyR.ang)*40, joyR.oy+Math.sin(joyR.ang)*40, 20, 0, 7); ctx.stroke();
    }

    // Minimap
    mCtx.fillStyle="#000"; mCtx.fillRect(0,0,100,100);
    const s = 100/2400;
    state.enemies.forEach(e => { if(!e.dead){ mCtx.fillStyle="red"; mCtx.fillRect(e.x*s, e.y*s, 2, 2); }});
    Object.keys(state.players).forEach(id => { 
        mCtx.fillStyle = id===myId ? "#fff" : "#00f";
        const px = id===myId ? localPlayer.x : state.players[id].x;
        const py = id===myId ? localPlayer.y : state.players[id].y;
        mCtx.fillRect(px*s, py*s, 3, 3);
    });
}
loop();

function up(t) { socket.emit('levelUpChoice', {roomId, choice:t}); document.getElementById('levelScreen').classList.add('hidden'); }
function buildWall() { socket.emit('build', {roomId}); }
function respawn() { socket.emit('respawn', roomId); }
</script>
</body>
</html>
