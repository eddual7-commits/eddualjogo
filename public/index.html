<script>
/* ================= CONFIGURAÇÃO ================= */
const socket = io()
const canvas = document.getElementById("game")
const ctx = canvas.getContext("2d")
const minimap = document.getElementById("minimap")
const mctx = minimap.getContext("2d")

// Elementos UI
const menuOverlay = document.getElementById("menuOverlay")
const hud = document.getElementById("hud")
const attackBtn = document.getElementById("attackBtn")
const roomDisplay = document.getElementById("roomDisplay")
const createBtn = document.getElementById("createBtn")
const joinBtn = document.getElementById("joinBtn")
const roomInput = document.getElementById("roomInput")

function resize() {
  canvas.width = innerWidth
  canvas.height = innerHeight
}
resize()
addEventListener("resize", resize)

/* ================= MUNDO & CÂMERA ================= */
const WORLD = { w: 2400, h: 2400 }
let camera = { x: 0, y: 0 }

/* ================= ESTADO DO JOGO ================= */
let roomId = null
let myId = null
let isGameRunning = false

// Jogadores
let serverPlayers = {}
const smoothPlayers = {} 

// Jogador Local
let localPlayer = { 
  x: 1200, y: 1200, r: 16, 
  hp: 100, maxHp: 100, 
  state: 'idle',
  class: 'warrior' 
}
let localInit = false

// A FADA 
let fairy = { x: 1200, y: 1200, angle: 0 }

/* ================= CONEXÃO ================= */
socket.on("connect", () => myId = socket.id)

// Função que esconde o menu e mostra o jogo
function startGameUI(code) {
  roomId = code
  roomDisplay.innerText = "Sala: " + code
  menuOverlay.classList.add("hidden") // Esconde menu
  hud.style.display = "block"         // Mostra HUD
  attackBtn.style.display = "block"   // Mostra Botão
  minimap.style.display = "block"     // Mostra Mapa
  isGameRunning = true
}

// CRIAR SALA (Quem cria recebe o ID do server)
createBtn.onclick = () => socket.emit("createRoom")

socket.on("roomCreated", id => startGameUI(id))

// ENTRAR NA SALA (Correção aqui: força a entrada visualmente)
joinBtn.onclick = () => {
  const code = roomInput.value.trim().toUpperCase()
  if (!code) return alert("Digite um código!")
  
  // 1. Avisa o server
  socket.emit("joinRoom", code)
  
  // 2. Inicia o jogo visualmente (Assumindo sucesso, igual ao código antigo)
  startGameUI(code)
}

socket.on("updatePlayers", data => {
  serverPlayers = data

  // Atualiza players remotos
  for (const id in serverPlayers) {
    if (id === myId) continue
    if (!smoothPlayers[id]) {
      smoothPlayers[id] = { x: data[id].x, y: data[id].y, r: 16, hp: 100 }
    }
  }

  // Sincroniza posição inicial APENAS na primeira vez
  if (!localInit && serverPlayers[myId]) {
    localPlayer.x = serverPlayers[myId].x
    localPlayer.y = serverPlayers[myId].y
    localInit = true
  }
})

/* ================= LÓGICA DE JOGO (CLIENT SIDE) ================= */
let enemies = []
function initEnemies() {
  for (let i = 0; i < 10; i++) {
    enemies.push({
      x: 1000 + Math.random() * 400,
      y: 1000 + Math.random() * 400,
      r: 16, hp: 30, maxHp: 30,
      speed: 1.5 + Math.random() * 0.5
    })
  }
}
initEnemies()

let isAttacking = false
attackBtn.onclick = () => {
  if (isAttacking) return
  
  isAttacking = true
  localPlayer.state = 'attack'
  
  // Shake leve na câmera
  const shake = 5
  camera.x += (Math.random() - 0.5) * shake
  camera.y += (Math.random() - 0.5) * shake

  // Dano Local (Visual)
  const range = localPlayer.class === 'warrior' ? 80 : 250
  const dmg = localPlayer.class === 'warrior' ? 10 : 5
  
  enemies.forEach(e => {
    const dist = Math.hypot(e.x - localPlayer.x, e.y - localPlayer.y)
    if (dist < range) {
      e.hp -= dmg
      // Knockback
      const angle = Math.atan2(e.y - localPlayer.y, e.x - localPlayer.x)
      e.x += Math.cos(angle) * 20
      e.y += Math.sin(angle) * 20
    }
  })
  
  enemies = enemies.filter(e => e.hp > 0)

  setTimeout(() => {
    isAttacking = false
    localPlayer.state = 'idle'
  }, 300)
}

/* ================= DRAW ================= */
function drawGrid() {
  const gridSize = 100
  ctx.strokeStyle = "#1a1d26"
  ctx.lineWidth = 2

  const startX = Math.floor(camera.x / gridSize) * gridSize
  const startY = Math.floor(camera.y / gridSize) * gridSize

  for (let x = startX; x < camera.x + canvas.width; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, camera.y); ctx.lineTo(x, camera.y + canvas.height); ctx.stroke();
  }
  for (let y = startY; y < camera.y + canvas.height; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(camera.x, y); ctx.lineTo(camera.x + canvas.width, y); ctx.stroke();
  }
}

function drawHealthBar(x, y, hp, max, color = "#ff4444") {
  const w = 40, h = 6
  ctx.fillStyle = "#333"
  ctx.fillRect(x - w/2, y - 30, w, h)
  ctx.fillStyle = color
  ctx.fillRect(x - w/2, y - 30, w * (hp/max), h)
}

function drawFairy() {
  fairy.angle += 0.05
  const orbitDist = 50
  const targetX = localPlayer.x + Math.cos(fairy.angle) * orbitDist
  const targetY = localPlayer.y + Math.sin(fairy.angle) * orbitDist
  
  fairy.x += (targetX - fairy.x) * 0.1
  fairy.y += (targetY - fairy.y) * 0.1

  ctx.shadowBlur = 15; ctx.shadowColor = "#00ffff"; ctx.fillStyle = "#fff"
  ctx.beginPath(); ctx.arc(fairy.x, fairy.y, 6, 0, Math.PI*2); ctx.fill()
  
  ctx.shadowBlur = 0; ctx.fillStyle = "rgba(200, 255, 255, 0.5)"
  ctx.beginPath(); ctx.ellipse(fairy.x - 5, fairy.y, 8, 4, Math.PI/4, 0, Math.PI*2); ctx.fill()
  ctx.beginPath(); ctx.ellipse(fairy.x + 5, fairy.y, 8, 4, -Math.PI/4, 0, Math.PI*2); ctx.fill()
}

/* ================= LOOP ================= */
let lastTime = 0
let serverTimer = 0

function gameLoop(timestamp) {
  const dt = timestamp - lastTime
  lastTime = timestamp

  ctx.clearRect(0, 0, canvas.width, canvas.height)
  ctx.fillStyle = "#0b0d14"
  ctx.fillRect(0, 0, canvas.width, canvas.height)

  if (!isGameRunning) {
    requestAnimationFrame(gameLoop)
    return
  }

  // 1. Input Joystick
  let moving = false
  if (window.joystick) {
    if (window.joystick.dx !== 0 || window.joystick.dy !== 0) moving = true
    const speed = 6
    localPlayer.x += window.joystick.dx * speed
    localPlayer.y += window.joystick.dy * speed
  }
  
  localPlayer.x = Math.max(0, Math.min(WORLD.w, localPlayer.x))
  localPlayer.y = Math.max(0, Math.min(WORLD.h, localPlayer.y))

  if (!isAttacking) localPlayer.state = moving ? 'run' : 'idle'

  // 2. Server Sync
  serverTimer += dt
  if (serverTimer > 50 && roomId) { 
    serverTimer = 0
    socket.emit("move", { roomId, x: localPlayer.x, y: localPlayer.y })
  }

  // 3. Interpolation
  for (const id in smoothPlayers) {
    const target = serverPlayers[id]
    if (target) {
      smoothPlayers[id].x += (target.x - smoothPlayers[id].x) * 0.2
      smoothPlayers[id].y += (target.y - smoothPlayers[id].y) * 0.2
    }
  }

  // 4. Camera
  camera.x += (localPlayer.x - camera.x - canvas.width/2) * 0.1
  camera.y += (localPlayer.y - camera.y - canvas.height/2) * 0.1

  ctx.save()
  ctx.translate(-camera.x, -camera.y)
  
  drawGrid()

  // Inimigos
  enemies.forEach(e => {
    const dist = Math.hypot(localPlayer.x - e.x, localPlayer.y - e.y)
    if (dist < 400 && dist > 30) {
       e.x += ((localPlayer.x - e.x) / dist) * e.speed
       e.y += ((localPlayer.y - e.y) / dist) * e.speed
    }
    ctx.fillStyle = "#ff5555"
    ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill()
    drawHealthBar(e.x, e.y, e.hp, e.maxHp)
  })

  // Players
  const allPlayers = [{id: myId, ...localPlayer}, ...Object.keys(smoothPlayers).map(id => ({id, ...smoothPlayers[id]}))]
  
  allPlayers.forEach(p => {
    const isMe = p.id === myId
    const color = isMe ? "#5aa9ff" : "#ffb86b"
    
    if (p.state === 'attack') {
        ctx.fillStyle = "#fff"
        ctx.beginPath(); ctx.arc(p.x, p.y, p.r + 5, 0, Math.PI*2); ctx.fill()
    }

    ctx.fillStyle = color
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI*2); ctx.fill()
    
    ctx.fillStyle = "#fff"
    ctx.font = "bold 14px Arial"
    ctx.textAlign = "center"
    const name = (Object.keys(serverPlayers)[0] === p.id) ? "Edu" : "Kally"
    ctx.fillText(name, p.x, p.y - 25)

    drawHealthBar(p.x, p.y - 5, 100, 100, "#5aa9ff")
  })
  
  drawFairy()

  ctx.restore()

  // Minimap
  mctx.clearRect(0,0, minimap.width, minimap.height)
  allPlayers.forEach(p => {
    const mx = (p.x / WORLD.w) * minimap.width
    const my = (p.y / WORLD.h) * minimap.height
    mctx.fillStyle = p.id === myId ? "#5aa9ff" : "#ffb86b"
    mctx.fillRect(mx-2, my-2, 4, 4)
  })
  enemies.forEach(e => {
    const mx = (e.x / WORLD.w) * minimap.width
    const my = (e.y / WORLD.h) * minimap.height
    mctx.fillStyle = "#ff5555"
    mctx.fillRect(mx-1, my-1, 3, 3)
  })

  requestAnimationFrame(gameLoop)
}

requestAnimationFrame(gameLoop)
</script>

