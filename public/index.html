<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>RPG Legends</title>

<style>
/* CSS CRÍTICO PARA MOBILE */
* { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
body { margin: 0; background: #000; overflow: hidden; font-family: 'Verdana', sans-serif; }

/* UI Layers */
#ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

/* Menu */
.menu-screen { pointer-events: auto; background: rgba(0,0,0,0.9); width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; }
.menu-screen h1 { color: #ffcc00; font-size: 40px; text-shadow: 0 0 20px #ff0000; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 20px; }
input { background: #222; border: 2px solid #555; color: #fff; padding: 15px; font-size: 20px; text-align: center; border-radius: 8px; text-transform: uppercase; width: 250px; }
button { background: linear-gradient(to bottom, #444, #222); color: #fff; border: 2px solid #888; padding: 15px 30px; font-size: 18px; font-weight: bold; border-radius: 8px; cursor: pointer; width: 250px; }
button:active { background: #666; transform: scale(0.98); }

/* HUD */
#hud { display: none; padding: 20px; }
.hp-container { width: 250px; height: 24px; background: #222; border: 3px solid #000; border-radius: 12px; overflow: hidden; position: relative; }
.hp-bar { height: 100%; background: linear-gradient(90deg, #ff3333, #aa0000); width: 100%; transition: width 0.2s; }
.hp-text { position: absolute; top: 0; left: 0; width: 100%; text-align: center; color: #fff; font-weight: bold; font-size: 14px; line-height: 24px; text-shadow: 1px 1px 0 #000; }

/* CONTROLES */
#joystick-zone { position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; pointer-events: auto; }
#attackBtn {
  position: absolute; bottom: 60px; right: 40px;
  width: 90px; height: 90px;
  background: radial-gradient(circle, #ffcc00, #ff8800);
  border: 4px solid #fff; border-radius: 50%;
  box-shadow: 0 0 20px rgba(255, 165, 0, 0.6);
  pointer-events: auto;
  display: flex; align-items: center; justify-content: center;
  font-size: 30px;
}
#attackBtn:active { transform: scale(0.9); filter: brightness(1.2); }

/* Efeitos de Dano (Tela Vermelha) */
#damage-overlay { position: absolute; top:0; left:0; width:100%; height:100%; background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s; }

canvas { display: block; }
</style>
</head>
<body>

<div id="ui-layer">
    <div id="menu" class="menu-screen">
        <h1>⚔️ RPG LEGENDS</h1>
        <button id="createBtn">CRIAR MUNDO</button>
        <input id="roomInput" placeholder="CÓDIGO DA SALA">
        <button id="joinBtn">ENTRAR NA BATALHA</button>
    </div>

    <div id="hud">
        <div class="hp-container">
            <div id="hpBar" class="hp-bar"></div>
            <div id="hpText" class="hp-text">100/100</div>
        </div>
        <div style="color: #888; margin-top: 5px; font-size: 12px;" id="roomDisplay"></div>
    </div>
</div>

<div id="damage-overlay"></div>
<div id="attackBtn" style="display:none">⚔️</div>

<canvas id="game"></canvas>

<script src="/socket.io/socket.io.js"></script>
<script>
/* === ENGINE GRÁFICA (SPRITES) === */
const sprites = {
    hero: new Image(),
    enemy: new Image(),
    grass: new Image(),
    prop: new Image()
};

// Tenta carregar da pasta public. Se falhar, usa null (e o jogo desenha formas)
sprites.hero.src = 'hero.png';
sprites.enemy.src = 'enemy.png';
sprites.grass.src = 'grass.png';
sprites.prop.src = 'prop.png';

/* === AUDIO SYSTEM === */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type) {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const t = audioCtx.currentTime;

    if (type === 'hit') { // Som de soco
        osc.frequency.setValueAtTime(100, t); osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.15);
        gain.gain.setValueAtTime(0.5, t); gain.gain.linearRampToValueAtTime(0, t + 0.15);
        osc.start(); osc.stop(t + 0.15);
    } else if (type === 'sword') { // Som de espada
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.3);
        gain.gain.setValueAtTime(0.3, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
        osc.start(); osc.stop(t + 0.3);
    }
}

/* === SETUP === */
const socket = io();
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let myId = null, roomId = null;
let camera = { x: 0, y: 0 };
let localPlayer = { x: 1200, y: 1200, hp: 100, maxHp: 100, facing: 0 };
let enemies = [], players = {};
let particles = [];

// Cenário (Tiles de Grama)
const TILE_SIZE = 512; // Grama grande para performance

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
resize(); window.addEventListener("resize", resize);

/* === REDE === */
socket.on('connect', () => myId = socket.id);

const startFn = (id) => {
    roomId = id;
    document.getElementById('menu').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('attackBtn').style.display = 'flex';
    document.getElementById('roomDisplay').innerText = "SALA: " + id;
};

document.getElementById('createBtn').onclick = () => socket.emit('createRoom');
document.getElementById('joinBtn').onclick = () => {
    const c = document.getElementById('roomInput').value.trim().toUpperCase();
    if(c) socket.emit('joinRoom', c);
};

socket.on('roomCreated', startFn);
socket.on('joinedRoom', startFn);

socket.on('updateWorld', (data) => {
    enemies = data.enemies;
    players = data.players;
    
    if(players[myId]) {
        const p = players[myId];
        // Flash de dano
        if (p.hp < localPlayer.hp) {
            document.getElementById('damage-overlay').style.opacity = 0.5;
            setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 200);
        }
        localPlayer.hp = p.hp;
        
        // Atualiza HUD
        document.getElementById('hpBar').style.width = (p.hp/p.maxHp*100) + "%";
        document.getElementById('hpText').innerText = Math.ceil(p.hp) + "/" + p.maxHp;
    }
});

/* === INPUT MULTITOUCH REESCRITO === */
let joystick = { active: false, id: null, dx: 0, dy: 0, originX: 0, originY: 0, currX: 0, currY: 0 };
let isAttacking = false;

// Captura toques na tela inteira, mas filtra lógica
canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
document.getElementById('attackBtn').addEventListener('touchstart', handleAttack, { passive: false });

function handleTouchStart(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        // Se toque for na metade esquerda e não tiver joystick ativo
        if (t.clientX < window.innerWidth / 2 && !joystick.active) {
            joystick.active = true;
            joystick.id = t.identifier;
            joystick.originX = t.clientX;
            joystick.originY = t.clientY;
            joystick.currX = t.clientX;
            joystick.currY = t.clientY;
        }
    }
}

function handleTouchMove(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (t.identifier === joystick.id) {
            joystick.currX = t.clientX;
            joystick.currY = t.clientY;
            
            // Calcula vetor normalizado
            const dx = joystick.currX - joystick.originX;
            const dy = joystick.currY - joystick.originY;
            const dist = Math.min(Math.hypot(dx, dy), 50); // Raio max 50
            const angle = Math.atan2(dy, dx);
            
            joystick.dx = (dist / 50) * Math.cos(angle);
            joystick.dy = (dist / 50) * Math.sin(angle);
        }
    }
}

function handleTouchEnd(e) {
    e.preventDefault();
    for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === joystick.id) {
            joystick.active = false;
            joystick.dx = 0; joystick.dy = 0;
        }
    }
}

function handleAttack(e) {
    e.preventDefault(); // Impede zoom/scroll
    e.stopPropagation(); // Impede que o canvas pegue esse toque
    if (isAttacking) return;
    
    isAttacking = true;
    playSound('sword');
    socket.emit('attack', { roomId });
    
    // Efeito visual local imediato
    if(players[myId]) players[myId].state = 'attack';
    setTimeout(() => { 
        isAttacking = false; 
        if(players[myId]) players[myId].state = 'idle';
    }, 250);
}

/* === RENDERIZAÇÃO === */
function drawSprite(img, x, y, w, h, rotation) {
    // Se a imagem carregou (width > 0), desenha ela. Senão, desenha quadrado.
    if (img && img.complete && img.naturalHeight !== 0) {
        ctx.save();
        ctx.translate(x, y);
        if (rotation) ctx.rotate(rotation);
        ctx.drawImage(img, -w/2, -h/2, w, h);
        ctx.restore();
        return true;
    }
    return false;
}

function loop() {
    // Limpa tela
    ctx.fillStyle = "#111";
    ctx.fillRect(0,0,canvas.width, canvas.height);

    if (!roomId || !players[myId]) {
        requestAnimationFrame(loop);
        return;
    }

    // 1. LÓGICA DE MOVIMENTO
    if (joystick.active) {
        const speed = 7;
        localPlayer.x += joystick.dx * speed;
        localPlayer.y += joystick.dy * speed;
        localPlayer.x = Math.max(0, Math.min(2400, localPlayer.x));
        localPlayer.y = Math.max(0, Math.min(2400, localPlayer.y));
        localPlayer.facing = Math.atan2(joystick.dy, joystick.dx);
        
        socket.emit('move', { 
            roomId, x: localPlayer.x, y: localPlayer.y, 
            state: 'run', facing: localPlayer.facing 
        });
    }

    // Camera
    camera.x += (localPlayer.x - camera.x - canvas.width/2) * 0.1;
    camera.y += (localPlayer.y - camera.y - canvas.height/2) * 0.1;

    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    // 2. DESENHO DO CHÃO (Tiled)
    const startCol = Math.floor(camera.x / TILE_SIZE);
    const endCol = startCol + (canvas.width / TILE_SIZE) + 1;
    const startRow = Math.floor(camera.y / TILE_SIZE);
    const endRow = startRow + (canvas.height / TILE_SIZE) + 1;

    for (let c = startCol; c <= endCol; c++) {
        for (let r = startRow; r <= endRow; r++) {
            if(!drawSprite(sprites.grass, c * TILE_SIZE + 256, r * TILE_SIZE + 256, TILE_SIZE, TILE_SIZE)) {
                // Fallback Grama
                ctx.fillStyle = (c+r)%2 === 0 ? "#1a331a" : "#142914";
                ctx.fillRect(c*TILE_SIZE, r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // 3. INIMIGOS
    enemies.forEach(e => {
        if (e.dead) return;
        
        // Se a sprite falhar, desenha o "monstro vermelho"
        if(!drawSprite(sprites.enemy, e.x, e.y, 64, 64)) {
            ctx.fillStyle = "#cc0000";
            ctx.beginPath(); ctx.arc(e.x, e.y, 25, 0, Math.PI*2); ctx.fill();
            // Olhos
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.arc(e.x-10, e.y-5, 8, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(e.x+10, e.y-5, 8, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#000"; // Pupilas
            ctx.beginPath(); ctx.arc(e.x-10, e.y-5, 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(e.x+10, e.y-5, 3, 0, Math.PI*2); ctx.fill();
        }

        // Barra de Vida Inimigo
        ctx.fillStyle = "black"; ctx.fillRect(e.x-20, e.y-40, 40, 6);
        ctx.fillStyle = "red"; ctx.fillRect(e.x-20, e.y-40, 40 * (e.hp/e.maxHp), 6);
    });

    // 4. JOGADORES
    for (const id in players) {
        const p = players[id];
        const isMe = id === myId;
        const x = isMe ? localPlayer.x : p.x;
        const y = isMe ? localPlayer.y : p.y;

        // Desenha Sprite ou Fallback
        if(!drawSprite(sprites.hero, x, y, 64, 64)) {
            ctx.fillStyle = p.role === 'warrior' ? "#00aaff" : "#ff00ff";
            ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI*2); ctx.fill();
            // Mãos
            ctx.beginPath(); ctx.arc(x+20, y, 8, 0, Math.PI*2); ctx.fill();
        }

        // Efeito de Ataque (Espada)
        if (p.state === 'attack') {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(p.facing);
            
            // Desenho da Espada (Visual bonito feito no canvas)
            ctx.beginPath();
            ctx.moveTo(10, -5); ctx.lineTo(60, -5); ctx.lineTo(70, 0); ctx.lineTo(60, 5); ctx.lineTo(10, 5);
            ctx.fillStyle = "#fff"; ctx.fill(); // Lâmina
            ctx.fillStyle = "#gold"; ctx.fillRect(0, -10, 10, 20); // Guarda
            
            // Rastro de corte
            ctx.beginPath();
            ctx.arc(0, 0, 60, -0.5, 0.5);
            ctx.strokeStyle = "rgba(255,255,255,0.5)";
            ctx.lineWidth = 10;
            ctx.stroke();
            
            ctx.restore();
        }
    }

    // 5. HUD JOYSTICK (Visualização)
    if (joystick.active) {
        ctx.restore(); // Sai da camera
        ctx.beginPath();
        ctx.arc(joystick.originX, joystick.originY, 50, 0, Math.PI*2);
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 4;
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(joystick.currX, joystick.currY, 20, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.5)";
        ctx.fill();
    } else {
        ctx.restore();
    }

    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
